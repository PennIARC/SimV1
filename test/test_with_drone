import random
import time
import math
from path_planning.greedy_path_planning import GreedyBottleneckPlanner

def clear_terminal():
    print("\033[H\033[J", end="")

def render(path, drone_pos):
    path_set = set(path) if path else set()
    print("Legend: D=Drone  *=Planned Path  X=Mine  S=Start  G=Goal\n")

    for y in reversed(range(HEIGHT)):
        row = ""
        for x in range(WIDTH):
            if (x, y) == drone_pos:
                row += " D "
            elif (x, y) in mine_cells:
                row += " X "
            elif (x, y) in path_set:
                row += " * "
            elif x == 0:
                row += " S "
            elif x == WIDTH - 1:
                row += " G "
            else:
                row += " . "
        print(row)


WIDTH = 30
HEIGHT = 10
NUM_MINES = 40
MINE_RADIUS = 0  # foot safety radius
random.seed(42)

# The entire map is known.
known_map = [[True for _ in range(WIDTH)] for _ in range(HEIGHT)]
clearance_map = [[0 for _ in range(WIDTH)] for _ in range(HEIGHT)]
all_cells = [(x, y) for x in range(WIDTH) for y in range(HEIGHT)]
mine_cells = set(random.sample(all_cells, NUM_MINES))

for y in range(HEIGHT):
    for x in range(WIDTH):
        if (x, y) in mine_cells:
            clearance_map[y][x] = 0.0
            continue

        min_dist = math.inf
        for mx, my in mine_cells:
            d = math.hypot(x - mx, y - my)
            min_dist = min(min_dist, d)

        clearance_map[y][x] = max(0.0, min_dist - MINE_RADIUS)


start_cells = [(0, y) for y in range(HEIGHT)]
goal_cells = [(WIDTH - 1, y) for y in range(HEIGHT)]

planner = GreedyBottleneckPlanner(
    height=HEIGHT,
    width=WIDTH,
    start_cells=start_cells,
    goal_cells=goal_cells
)


# 初始无人机位置（从 start 边界选一个安全点）
current_pos = start_cells[HEIGHT // 2]

MAX_STEPS = 200
SLEEP_TIME = 0.2  # 控制动画速度

for step in range(MAX_STEPS):
    result = planner.plan(known_map, clearance_map)

    clear_terminal()

    if result is None:
        print("No safe path found. Stopping.")
        break

    path = result["path"]

    render(path, current_pos)

    print(f"\nStep {step}")
    print(f"Bottleneck: {result['bottleneck']:.2f}")
    print(f"Path length: {result['length']}")

    # 到达终点
    if current_pos in goal_cells:
        print("\nReached goal!")
        break

    # 执行路径的第一步（receding horizon）
    if len(path) > 1:
        next_pos = path[1]
    else:
        print("\nNo forward progress possible.")
        break

    current_pos = next_pos
    time.sleep(SLEEP_TIME)

